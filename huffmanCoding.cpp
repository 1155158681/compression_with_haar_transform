/*
	HuffmanCoding
	This file contains the self-implemented
	Huffman coding algorithm for array of
	unsigned characters.
*/

#include "huffmanCoding.h"
#include <string>
#include <vector>
#include <stack>
#include <queue>
#include <stdexcept>
#include <iostream>

namespace c173 {

	typedef Binary_Node<unsigned char> Binary_Node_uchar;
	
	Huffman_Coding_uchar::Huffman_Coding_uchar() {
		// Initialization
		huffman_tree = NULL;
		
		for(int i = 0; i < 256; i++)
			codec[i] = "";
	}
	
	Huffman_Coding_uchar::Huffman_Coding_uchar(unsigned char* raw_data_array, int array_size) {
		// Initialization
		huffman_tree = NULL;
		
		for(int i = 0; i < 256; i++)
			codec[i] = "";
		
		evaluate_codec(raw_data_array, array_size);
	}
	
	/*
		By the assumption that the tree_stream is generated by this class!!
		
		The tree_stream would have the data structure as follows:
			[Tree structure layout][Tree data]
		
		Tree structure layout:
			0 as structure node (ie. not leaf)
			1 as leaf
		
		Tree data:
			stored in next bytes after tree structure layout (uchar size = 1 byte)
		
		Example:

			 /\
			/  \
		   A  / \
		     /\ /\
			 BC DE
		
		Tree structure layout: 10011011[ 0 (TREE END INDICATOR)]
		Tree data: ABCDE
	*/
	void Huffman_Coding_uchar::interprut_tree(unsigned char* tree_stream, int tree_stream_size) {
		huffman_tree = new Binary_Node_uchar();

		std::stack<Binary_Node_uchar*> node_stack;
		node_stack.push(huffman_tree);
		std::queue<Binary_Node_uchar*> leaf_queue;
		
		for(int i = 0; i < tree_stream_size; i++) {
			if(node_stack.empty()) {
				// start reading data
				leaf_queue.front()->set_data(tree_stream[i]);
				leaf_queue.pop();
			} else {
				// get tree structure
				for(int j = 0; j < sizeof(unsigned char) * 8 && !node_stack.empty(); j++) {
					// Get bit
					int bit = (tree_stream[i] & (1 << (7 - j))) >> (7 - j);
					switch(bit) {
						case 0: {
							Binary_Node_uchar* append_node = new Binary_Node_uchar();
							
							if(node_stack.top()->get_left_node() == NULL) {
								node_stack.top()->set_left_node(append_node);
							}
							else {
								// pop right setted nodes
								while(!node_stack.empty() && node_stack.top()->get_right_node() != NULL)
									node_stack.pop();
								// set right node
								if(!node_stack.empty())
									node_stack.top()->set_right_node(append_node);
							}
							
							if(!node_stack.empty())
								node_stack.push(append_node);
							else
								delete append_node;
							break;
						}
						case 1: {
							Binary_Node_uchar* append_node = new Binary_Node_uchar(0);
							leaf_queue.push(append_node);

							if(node_stack.top()->get_left_node() == NULL) {
								node_stack.top()->set_left_node(append_node);
							} else {
								// pop right setted nodes
								while(node_stack.top()->get_right_node() != NULL)
									node_stack.pop();
								// set right node
								node_stack.top()->set_right_node(append_node);
							}
							break;
						}
						default:
							break;
					}
				}
			}
		}
		
		evaluate_codec();
	}

	std::vector<unsigned char> Huffman_Coding_uchar::make_tree_stream() {
		std::vector<unsigned char> tree_stream;
		std::vector<unsigned char> data_stream;
		unsigned char buffer = 0;
		int buffer_cursor = 0;	// buffer index : |01234567|
		std::string tree_struct = "";
		helper_make_tree_stream(huffman_tree, tree_struct, data_stream);
		tree_struct += '0';	// tree end indicator
		
		std::clog << "Tree struct: " << tree_struct << std::endl;

		// covert tree_struct from string to bit stream
		for(int i = 0; i < tree_struct.length(); i++) {
			if(tree_struct[i] == '1') {
				buffer |= (1 << (7 - buffer_cursor));
			}
			buffer_cursor++;
			
			// flush buffer if needed
			if(buffer_cursor == sizeof(unsigned char) * 8) {
				tree_stream.push_back(buffer);
				buffer = 0;
				buffer_cursor = 0;
			}
		}
		// flush remaining tree struct
		tree_stream.push_back(buffer);

		// append all data into stream
		for(int i = 0; i < data_stream.size(); i++)
			tree_stream.push_back(data_stream[i]);
		
		return tree_stream;
	}

	void Huffman_Coding_uchar::helper_make_tree_stream(Binary_Node_uchar* node, std::string &tree_struct, std::vector<unsigned char>& data_stream) {
		if(node->get_left_node()->isEmpty()) {
			tree_struct += '0';
			helper_make_tree_stream(node->get_left_node(), tree_struct, data_stream);
		}
		else {
			tree_struct += '1';
			data_stream.push_back(node->get_left_node()->get_data());
		}

		if(node->get_right_node()->isEmpty()) {
			tree_struct += '0';
			helper_make_tree_stream(node->get_right_node(), tree_struct, data_stream);
		} else {
			tree_struct += '1';
			data_stream.push_back(node->get_right_node()->get_data());
		}
	}

	void Huffman_Coding_uchar::evaluate_codec(unsigned char* raw_data_array, int array_size) {
		// Constructing Huffman tree
		huffman_tree = construct_tree(raw_data_array, array_size);
		evaluate_codec();
	}
	
	void Huffman_Coding_uchar::evaluate_codec() {
		// Translate tree to codec by traversing the whole tree
		helper_traverse_tree(huffman_tree, "");
	}

	// Helper function for evaluate_codec(unsigned char*, int);
	void Huffman_Coding_uchar::helper_traverse_tree(Binary_Node_uchar* node, std::string code) {
		if(!node->isEmpty()) {
			// Record code word
			codec[(int) node->get_data()] = code;
		} else {
			if(node->get_left_node() != NULL)
				helper_traverse_tree(node->get_left_node(), code + "0");
			if(node->get_right_node() != NULL)
				helper_traverse_tree(node->get_right_node(), code + "1");
		}
	}

	// Note that code_book must have NON-REPEATED elements
	Binary_Node_uchar* Huffman_Coding_uchar::construct_tree(unsigned char* code_book, int *frequency, int cnt_code) {
		// Codes with frequency of ZERO(0) will not be included in Huffman Tree

		// std::vector holding nodes and corresponding frequencies
		// Note that this two arrays have to be concurrently modified
		std::vector<Binary_Node_uchar*> nodes;
		std::vector<int> node_freq;	// corresponding frequencies

		// Create Binary_Node for each code
		for(int i = 0; i < cnt_code; i++) {
			if(frequency[i] > 0) {
				nodes.push_back(new Binary_Node_uchar(code_book[i]));
				node_freq.push_back(frequency[i]);
			}
		}

		// Creating Huffman Tree
		while(nodes.size() > 1) {
			// Find the minimal two nodes and combine them
			// into a structual node with no data

			// Assume first two nodes are minimal
			int min1 = 0;	// index of 1st min node
			int min2 = 1;	// index of 2nd min node

			// Iterate through nodes to find real min nodes
			for(int i = 2; i < nodes.size(); i++) {
				int cursor = i;
				if(node_freq[min1] > node_freq[cursor]) {
					std::swap(cursor, min1);
				}
				if(node_freq[min2] > node_freq[cursor]) {
					min2 = cursor;
				}
			}

			// Combining two minial nodes
			Binary_Node_uchar *structual_node = new Binary_Node_uchar();
			structual_node->set_left_node(nodes[min1]);
			structual_node->set_right_node(nodes[min2]);

			int structual_freq = node_freq[min1] + node_freq[min2];

			// Delete the two nodes and insert the structual node
			// by moving the two nodes to back of vector and pop
			nodes[min1] = nodes.back();
			nodes.pop_back();
			node_freq[min1] = node_freq.back();
			node_freq.pop_back();

			nodes[min2] = nodes.back();
			nodes.pop_back();
			node_freq[min2] = node_freq.back();
			node_freq.pop_back();

			nodes.push_back(structual_node);
			node_freq.push_back(structual_freq);
		}
		
		return nodes.front();
	}

	Binary_Node_uchar* Huffman_Coding_uchar::construct_tree(unsigned char* raw_data_array, int array_size) {
		// Resolving a code book and frequency table
		unsigned char bucket[256] = {0};	// Contains all possible codes for uchar
		int frequency[256] = {0};

		// Initializing buckets
		for(int i = 0; i < 256; i++)
			bucket[i] = (unsigned char) i;

		for(int i = 0; i < array_size; i++) {
			frequency[(int) raw_data_array[i]]++;
		}

		return construct_tree(bucket, frequency, 256);
	}

	std::string Huffman_Coding_uchar::encode(unsigned char raw_data) {
		return codec[(int) raw_data];
	}

	unsigned char Huffman_Coding_uchar::decode(std::string code) {
		for(int i = 0; i < 256; i++)
			if(codec[i] == code)
				return i;
	}
	
	void Huffman_Coding_uchar::decode_stream(unsigned char* code_stream, int code_stream_size, unsigned char* decode_stream, int decode_stream_size) {
		if(huffman_tree == NULL)
			return;
		
		Binary_Node_uchar* node = huffman_tree;
		int decode_stream_cursor = 0;
		
		// decode until the decode_stream is full
		for(int i = 0; i < code_stream_size && decode_stream_cursor < decode_stream_size; i++) {
			// bit position: 01234567
			for(int j = 0; j < sizeof(unsigned char) * 8 && decode_stream_cursor < decode_stream_size; j++) {
				// Get bit
				int bit = (int)((code_stream[i] & (1 << (7 - j))) >> (7 - j));
				switch(bit) {
					case 0:
						node = node->get_left_node();
						break;
					case 1:
						node = node->get_right_node();
						break;
					default:
						break;
				}
				
				if(!node->isEmpty()) {
					// found leaf
					decode_stream[decode_stream_cursor] = node->get_data();
					node = huffman_tree;
					decode_stream_cursor++;
				}
			}
		}
	}
	
	// DEBUG
	void Huffman_Coding_uchar::print_huffman_tree() {
		huffman_tree->print_binary_node();
	}

	template <typename T>
	Binary_Node<T>::Binary_Node(T data) {
		left = right = NULL;
		this->data = data;
		flag_empty = false;
	}

	template <typename T>
	Binary_Node<T>::Binary_Node() {
		left = right = NULL;
		flag_empty = true;
	}

	template <typename T>
	Binary_Node<T>::~Binary_Node() {
		delete left;
		delete right;
	}

	template <typename T>
	void Binary_Node<T>::set_data(T data) {
		flag_empty = false;
		this->data = data;
	}

	template <typename T>
	T Binary_Node<T>::get_data() {
		if(!flag_empty)
			return data;
		else
			throw std::runtime_error("Getting data from empty Binary_Node!");
	}

	template <typename T>
	void Binary_Node<T>::clear_data() {
		flag_empty = true;
	}

	template <typename T>
	bool Binary_Node<T>::isEmpty() {
		return flag_empty;
	}

	template <typename T>
	Binary_Node<T>* Binary_Node<T>::get_left_node() {
		return left;
	}

	template <typename T>
	Binary_Node<T>* Binary_Node<T>::get_right_node() {
		return right;
	}

	template <typename T>
	void Binary_Node<T>::set_left_node(Binary_Node<T>* node) {
		// delete old node if any
		// Note that sub_nodes are removed along with it!
		delete left;
		left = node;
		
	}

	template <typename T>
	void Binary_Node<T>::set_right_node(Binary_Node<T>* node) {
		// delete old node if any
		// Note that sub_nodes are removed along with it!
		delete right;
		right = node;
	}
	
	template <typename T>
	void Binary_Node<T>::print_binary_node() {
		std::cout << "Node Val: " << ((isEmpty())?(-1):(get_data())) << std::endl;
		std::cout << "Left node: " << std::endl;
		
		if(left == NULL)
			std::cout << "NULL.";
		else
			left->print_binary_node();
			
		std::cout << std::endl;
		
		std::cout << "Right node: " << std::endl;
		
		if(right == NULL)
			std::cout << "NULL.";
		else
			right->print_binary_node();
			
		std::cout << "END OF NODE" << std::endl;
	}
}
